# 2장: 핵심 설계 원칙

> *"좋은 설계는 규칙을 맹목적으로 따르는 것이 아니라, 원칙을 충분히 깊이 이해하여 언제 어떻게 적용할지 아는 것입니다."*

---

## 학습 목표

이 장을 마치면 다음을 할 수 있게 됩니다:
- 5가지 SOLID 원칙을 모두 적용하여 코드 설계와 유지보수성을 개선할 수 있습니다
- DRY, KISS, YAGNI 원칙을 일상 개발 실무에 구현할 수 있습니다
- 적절한 관심사 분리를 통해 시스템을 설계할 수 있습니다
- 소프트웨어 모듈의 결합도와 응집도를 평가하고 최적화할 수 있습니다
- 서로 다른 설계 원칙 간의 정보에 입각한 트레이드오프를 만들 수 있습니다

---

## 2.1 SOLID 원칙: 견고하고 유지보수 가능한 시스템 구축

SOLID 원칙은 체계적으로 적용될 때 더 견고하고 유지보수 가능하며 확장 가능한 소프트웨어 시스템으로 이어지는 5가지 기본 설계 지침을 나타냅니다. 원래 Robert C. Martin에 의해 공식화된 이 원칙들은 객체지향 프로그래밍에서 널리 인정받지만 다양한 패러다임과 현대 개발 접근법에서도 관련성을 가집니다.

### SOLID가 중요한 이유

각 원칙을 자세히 살펴보기 전에, SOLID 원칙이 해결하는 문제들을 이해하는 것이 중요합니다:
- **경직성**: 모든 변경이 너무 많은 다른 부분에 영향을 미치기 때문에 변경하기 어려운 시스템
- **취약성**: 변경을 가할 때 예상치 못한 곳에서 깨지는 시스템
- **부동성**: 다른 애플리케이션에서 구성 요소를 쉽게 재사용할 수 없는 시스템
- **점성**: 설계 무결성을 보존하는 것보다 해킹하는 것이 더 쉬운 경우

---

### 2.1.1 단일 책임 원칙 (SRP)

> *"클래스는 하나의, 그리고 오직 하나의 변경 이유만을 가져야 한다."* - Robert C. Martin

#### 원칙 설명

단일 책임 원칙은 소프트웨어 시스템 내의 모든 클래스나 모듈이 단일하고 잘 정의된 기능 조각에 대해서만 책임져야 한다고 규정합니다. 이 원칙은 종종 "클래스는 한 가지 일만 해야 한다"로 오해되지만, 더 정확하게는 "클래스는 변경할 이유가 하나만 있어야 한다"로 설명됩니다.

#### 책임 식별하기

클래스가 SRP를 위반하는지 식별하려면 다음 질문들을 하세요:
1. **이해관계자는 누구인가?** 서로 다른 이해관계자는 서로 다른 변경 이유를 나타냅니다
2. **이 클래스가 변경되는 원인은 무엇인가?** 여러 이유는 여러 책임을 나타냅니다
3. **"그리고"나 "또는"을 사용하지 않고 한 문장으로 클래스를 설명할 수 있는가?**

#### SRP의 이점

- **더 쉬운 테스팅**: 더 작고 집중된 클래스는 포괄적으로 테스트하기 더 간단합니다
- **결합도 감소**: 단일 책임을 가진 클래스는 더 적은 의존성을 가집니다
- **유지보수성 향상**: 변경이 더 작고 격리된 코드 섹션에 영향을 미칩니다
- **재사용성 향상**: 집중된 클래스는 다른 맥락에서 유용할 가능성이 높습니다

#### 일반적인 SRP 위반

| 위반 유형 | 예시 | 문제 | 해결책 |
|---|---|---|---|
| **관심사 혼재** | `UserReportGenerator`가 데이터 로직과 이메일 전송을 모두 처리 | 두 가지 변경 이유: 데이터 형식 변경과 이메일 서비스 변경 | `ReportGenerator`와 `EmailService`로 분리 |
| **신 클래스** | `OrderManager`가 검증, 지속성, 알림, 계산을 모두 처리 | 여러 이해관계자, 여러 변경 이유 | 도메인 경계를 따라 집중된 서비스로 분해 |
| **유틸리티 클래스** | 관련 없는 헬퍼 메서드들을 가진 `Utils` 클래스 | 무한정 성장, 불분명한 목적 | 관련 기능을 위한 특정 유틸리티 클래스 생성 |

### 💡 **Vive 코딩 프롬프트: SRP 리팩토링 챌린지**

**시나리오**: 여러 책임을 처리하는 레거시 `UserReport` 클래스를 리팩토링해야 합니다.

**당신의 과제**: 
1. 클래스의 모든 책임을 식별하고 분리 계획을 수립하세요
2. 각 책임에 대한 이해관계자를 식별하세요
3. 새로운 클래스 구조를 설계하고 의존성을 관리하세요

---

### 2.1.2 개방-폐쇄 원칙 (OCP)

> *"소프트웨어 엔티티는 확장에는 열려있고 수정에는 닫혀있어야 한다."* - Bertrand Meyer

#### 원칙 설명

개방-폐쇄 원칙은 기존 코드를 수정하지 않고도 클래스의 동작을 확장할 수 있어야 한다고 명시합니다. 이것은 모순적으로 보일 수 있지만, 상속, 인터페이스, 컴포지션과 같은 추상화 메커니즘을 통해 달성할 수 있습니다.

#### 추상화를 통한 OCP 달성

**전략 1: 인터페이스 기반 확장**
```python
# 수정에는 닫혀있고, 확장에는 열려있음
class ReportExporter:
    def export(self, data: ReportData) -> str:
        raise NotImplementedError
    
class XMLExporter(ReportExporter):
    def export(self, data: ReportData) -> str:
        # XML 특정 구현
        pass

class JSONExporter(ReportExporter):
    def export(self, data: ReportData) -> str:
        # JSON 특정 구현
        pass
```

**전략 2: 구성 기반 동작**
```python
class NotificationService:
    def __init__(self, strategies: List[NotificationStrategy]):
        self.strategies = strategies
    
    def notify(self, message: Message):
        for strategy in self.strategies:
            strategy.send(message)
```

#### OCP의 이점

- **위험 감소**: 새로운 기능이 테스트된 코드를 변경할 필요가 없습니다
- **더 쉬운 유지보수**: 새로운 기능의 버그 수정이 기존 기능에 영향을 주지 않습니다
- **더 나은 테스팅**: 새로운 동작을 독립적으로 테스트할 수 있습니다
- **향상된 모듈성**: 명확한 확장 지점이 아키텍처를 더 이해하기 쉽게 만듭니다

### 💡 **Vive 코딩 프롬프트: 결제 처리 확장**

**시나리오**: 전자상거래 시스템에 새로운 결제 방법들을 추가해야 합니다.

**당신의 과제**:
1. 확장 친화적 아키텍처를 설계하세요
2. 기존 코드 수정 없이 새로운 결제 방법을 추가하는 방법을 구현하세요

---

### 2.1.3 리스코프 치환 원칙 (LSP)

> *"상위 클래스의 객체는 애플리케이션을 깨뜨리지 않고 하위 클래스의 객체로 교체할 수 있어야 한다."* - Barbara Liskov

파생 클래스가 프로그램의 정확성을 변경하지 않고 기본 클래스를 대체할 수 있어야 합니다.

### 💡 **Vive 코딩 프롬프트: 차량 계층 설계**

**시나리오**: 차량 렌탈 시스템을 위한 LSP 준수 차량 계층을 설계하세요.

---

### 2.1.4 인터페이스 분리 원칙 (ISP)

> *"클라이언트는 사용하지 않는 인터페이스에 의존하도록 강요받아서는 안 된다."* - Robert C. Martin

큰 인터페이스를 더 작고 구체적인 인터페이스로 분리하여 클라이언트가 필요한 메서드만 알면 되도록 합니다.

### 💡 **Vive 코딩 프롬프트: API 게이트웨이 인터페이스 설계**

**시나리오**: 마이크로서비스 아키텍처를 위한 모듈화된 API 게이트웨이 인터페이스를 설계하세요.

---

### 2.1.5 의존성 역전 원칙 (DIP)

> *"고수준 모듈은 저수준 모듈에 의존해서는 안 된다. 둘 다 추상화에 의존해야 한다."* - Robert C. Martin

고수준 모듈과 저수준 모듈 모두 추상화에 의존해야 합니다.

### 💡 **Vive 코딩 프롬프트: 전자상거래 주문 처리 시스템**

**시나리오**: DIP를 준수하는 주문 처리 시스템을 설계하고 의존성 주입을 구현하세요.

---

## 2.2 DRY, KISS, YAGNI: 실용적 설계 원칙

### 2.2.1 DRY (Don't Repeat Yourself)

> *"모든 지식 조각은 시스템 내에서 단일하고 명확하며 권위 있는 표현을 가져야 한다."*

지식과 의도의 중복을 피하는 것이 핵심입니다.

### 💡 **Vive 코딩 프롬프트: 데이터 검증 통합**

**시나리오**: 여러 모듈에서 반복되는 검증 로직을 통합하는 시스템을 설계하세요.

---

### 2.2.2 KISS (Keep It Simple, Stupid)

> *"단순성은 궁극의 정교함이다."* - Leonardo da Vinci

불필요한 복잡성을 피하고 가능한 한 간단한 솔루션을 선호합니다.

---

### 2.2.3 YAGNI (You Aren't Gonna Need It)

> *"필요할 때까지 기능을 추가하지 마라."* - Ron Jeffries

현재 필요하지 않은 기능을 구현하지 말라고 권고합니다.

### 💡 **Vive 코딩 프롬프트: 레거시 리포트 생성기 리팩토링**

**시나리오**: 과도하게 복잡해진 리포트 생성기를 KISS와 YAGNI 원칙에 따라 단순화하세요.

---

## 2.3 관심사의 분리와 모듈성

관심사의 분리는 복잡한 시스템을 별개의, 중복되지 않는 기능 섹션으로 나누는 설계 원칙입니다.

### 관심사 분리의 이점

1. **이해 가능성**: 각 모듈이 명확한 목적을 가집니다
2. **유지보수성**: 변경이 관련 모듈에만 영향을 미칩니다
3. **재사용성**: 잘 분리된 모듈은 다른 맥락에서 재사용할 수 있습니다
4. **테스트 가능성**: 각 관심사를 독립적으로 테스트할 수 있습니다

---

## 2.4 결합도와 응집도

### 결합도 (Coupling)

결합도는 모듈들이 서로 얼마나 의존하는지를 측정합니다. 낮은 결합도가 바람직합니다.

### 응집도 (Cohesion)

응집도는 모듈 내의 요소들이 얼마나 밀접하게 관련되어 있는지를 측정합니다. 높은 응집도가 바람직합니다.

---

## 장 요약

핵심 설계 원칙들은 고품질 소프트웨어의 기초를 형성합니다. SOLID 원칙은 견고하고 유지보수 가능한 객체지향 설계를 위한 프레임워크를 제공하며, DRY, KISS, YAGNI는 일상적인 개발 결정을 안내합니다.

이러한 원칙들은 독립적으로 적용되는 것이 아니라 함께 작동하여 "Vive 코딩" 철학을 지원하는 시너지 효과를 만들어냅니다.

### 핵심 요점

1. **원칙의 균형**: 설계 원칙들 간의 트레이드오프를 이해하고 맥락에 맞게 적용하세요
2. **점진적 개선**: 완벽한 설계를 한 번에 달성하려 하지 말고 지속적으로 개선하세요
3. **실용적 적용**: 원칙을 맹목적으로 따르지 말고 프로젝트의 실제 요구사항을 고려하세요
4. **팀 일관성**: 팀 전체가 동일한 설계 원칙을 이해하고 적용하도록 하세요

---

## 추가 읽기

- **다음 장**: 소프트웨어 아키텍처 이해 - 시스템 수준 설계 패턴과 아키텍처 결정
- **보충 자료**: 
  - *Clean Architecture* by Robert C. Martin
  - *Design Patterns* by Gang of Four
  - *Refactoring* by Martin Fowler 